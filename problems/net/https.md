# HTTPS

由于HTTP协议本身没有对传输内容进行任何加密并且客户端和服务端进行连接时也没有身份验证的机制，因此黑客就有机会伪造身份、监听或篡改信息。

为了解决上述安全问题，我们可以使用加密算法对内容进行加密。

## 方案一：对称加密

对称加密就是加密和解密用同一个密钥。客户端把要传输的消息用密钥进行加密，然后服务器用同一个密钥进行解密，反之亦然。

这种方式有以下几个缺点。

1. 客户端和服务器需要协商密钥，因为还没有密钥因此需要用明文传输密钥，存在泄漏的可能。
2. 客户端和服务端需要维护大量的密钥，浪费资源。

## 方案二：非对称加密

非对称加密有一对密钥，分别叫做公钥和私钥，可以用任意一个密钥加密然后用另一个密钥解密，公钥是公开的，私钥只是自己持有。在这种模式下服务器只需维护一对密钥，客户端发送请求时使用服务器公开的公钥对内容进行加密，服务器收到请求后用私钥进行解密；在返回消息时，服务器使用私钥进行加密，客服端收到后用公钥进行解密。

这种方式的缺点是，在服务器返回消息时，一旦消息被黑客截获，由于公钥是公开的，那么黑客也可以进行解密。此外非对称加密的效率通常比对称加密低。

## 方案三：对称加密+非对称加密

如果我们能解决方法一中客户端和服务器协商密码时密钥泄露的问题，那么在之后的传输中即使黑客截获了消息，也无法对解惑的消息进行解密了。

那么如何改进方法一呢？答案是用方法二的非对称加密来传输方法一中的密钥。客户端使用非对称加密中的公钥把对称加密中的密钥进行加密并发给服务器，服务器用私钥进行解密后就得到了客户端发来的密钥，之后的数据传输就可以用方法一中对称加密的方式了。HTTPS就是采用这种方案。

![](resources/https_1.png)

## 数字证书

那么HTTPS是如何拿到公钥呢？

HTTPS通过数字证书（Certificate）的机制来获得公钥，而证书由权威机构（Certificate Authority，CA）进行颁发，证书中有公钥

我们可以使用`openssl`工具创建一个证书。

```bash
# 生成私钥
openssl genrsa -out private.key 1024
# 根据私钥生成公钥
openssl rsa -in private.key -pubout -out public.pem

openssl 
```

引入了HTTPS。HTTPS协议是在HTTP协议的下层加入SSL协议。

## 参考

1. [《HTTPS原理详解》](https://blog.upyun.com/?p=1347)
2. [《Using OpenSSL》](https://dst.lbl.gov/~boverhof/openssl_certs.html)
