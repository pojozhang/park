# 类加载机制

## 类加载过程

类加载过程可以分为3步，分别是加载、连接和初始化，其中连接又可分为3步，分别是验证、准备和解析。

### 加载

加载阶段有以下3个步骤。

1. 通过类的全限定名获取定义此类的二进制字节流。我们可以通过各种渠道获得类的二进制字节流，如`.jar`、`.war`文件或是动态生成的字节流（比如动态代理技术）。
2. 将字节流代表的静态存储结构转化为虚拟机方法区的运行时数据结构。
3. 生成一个代表该类的`java.lang.Class`对象。

### 连接

#### 验证

验证阶段有以下4个步骤。

1. 文件格式验证。比如`.class`文件中的版本号是否在当前虚拟机可以处理的范围之内，常量池中是否有不被支持的常量类型等。
2. 元数据验证。对字节码进行语义分析，已确保其符合Java语言规范。比如类是否继承了不允许被继承的类，一个抽象类是否实现了所有的接口等。
3. 字节码验证。通过数据流和控制流分析，确定字节码语义的合法性。比如确保不会发生这样的情况：在操作栈中放入一个`int`类型的数据，取出时却按`long`类型来操作。
4. 符号引用验证。用来确保虚拟机在解析阶段将符号引用转为直接引用的操作能正常进行。比如验证通过符号引用中字符串形式的类的全限定名能否找到对应的类。

#### 准备

在这一阶段，虚拟机会为静态变量在方法区中分配内存并设置零值。比如下面的代码，在这一阶段过后`value`的值会是0而不是123。

```java
public static int value = 123;
```

但是下面这行代码在准备阶段value的值就已经是123了，仔细对比你可以发现，下面的字段是被`final`修饰的常量，虚拟机会在准备阶段就设置好常量的值。

```java
public static final int value = 123;
```

虚拟机不会在这个阶段为非静态变量在方法区中分配内存或赋值，这部分变量会在对象实例化时被分配到堆中。

#### 解析

在解析阶段，虚拟机会把常量池内的符号引用替换为直接引用。

### 初始化



## 类加载器

### 双亲委派模型
