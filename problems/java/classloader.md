# 类加载机制

本文介绍虚拟机类加载机制，其中部分概念涉及到[类文件结构](classfile.md)，建议先了解相关内容。

## 类加载过程

类加载过程可以分为3步，分别是加载、连接和初始化，其中连接又可分为3步，分别是验证、准备和解析。

### 加载

加载阶段有以下3个步骤。

1. 获取定义类的二进制字节流。我们可以通过各种渠道获得类的二进制字节流，如`.jar`、`.war`文件或是动态生成的字节流（比如动态代理技术）。
2. 将字节流代表的静态存储结构转化为虚拟机方法区的运行时数据结构。
3. 生成一个代表该类的`java.lang.Class`对象。

### 连接

#### 验证

这一阶段是为了保证类文件中的信息符合虚拟机的要求，有以下4个步骤。

1. 文件格式验证。比如类文件中的魔数是否正确，主次版本号是否在当前虚拟机支持的范围内，常量池中是否有不被支持的常量类型等。
2. 元数据验证。对字节码进行语义分析，已确保其符合Java语言规范。比如类是否继承了不允许被继承的类，一个抽象类是否实现了所有的接口等。
3. 字节码验证。通过数据流和控制流分析，确定字节码语义的合法性。比如确保不会发生这样的情况：在操作栈中放入一个`int`类型的数据，取出时却按`long`类型来操作。
4. 符号引用验证。用来确保虚拟机在解析阶段将符号引用转为直接引用的操作能正常进行，比如验证通过类的全限定名能否找到对应的类。这里的符号引用是指值常量池中`CONSTANT_Class_info`、`CONSTANT_Methodref_info`、`CONSTANT_Fieldref_info`等类型的常量；而直接引用就是指向目标对象的指针。

#### 准备

在这一阶段，虚拟机会为静态变量在方法区中分配内存并设置**零值**，每种类型都有自己的零值，如下表所示。

|  类型      |   零值   |
| --------- | -------- |
| boolean   | false    |
| byte      | 0        |
| char      | '\u0000' |
| short     | 0        |
| int       | 0        |
| long      | 0        |
| float     | 0.0      |
| double    | 0.0      |
| reference | null     |

下面的代码，**在这一阶段过后**`value`的值会是`0`而不是`123`。

```java
public static int value = 123;
```

但是下面这行代码在准备阶段过后，字段`value`的值就已经是`123`了。仔细对比你可以发现，下面的字段是被`final`修饰的常量并且它是基本类型，在[类文件结构](classfile.md/#constant-value)中提到过，在编译阶段编译器会为基本类型（或`String`类型）的常量增加一个`ConstantValue`的属性，虚拟机会在准备阶段就把`ConstantValue`属性的值赋给常量。

```java
public static final int value = 123;
```

此外，虚拟机**不会**在这个阶段为非静态变量在方法区中分配内存或赋值，这部分变量会在对象实例化时被分配到堆中。

#### 解析

在解析阶段，虚拟机会把常量池内的符号引用替换为直接引用。


### 初始化



## 类加载器

### 双亲委派模型
